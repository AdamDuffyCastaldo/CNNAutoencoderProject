---
phase: 05-inference
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/inference/tiling.py
autonomous: true

must_haves:
  truths:
    - "Tiles extracted from image with configurable overlap"
    - "Cosine ramp blending weights sum to 1.0 in overlap regions"
    - "Reconstructed image from tiles has no visible seams"
    - "Padding handles arbitrary input sizes"
  artifacts:
    - path: "src/inference/tiling.py"
      provides: "Tile extraction, blending weights, reconstruction"
      exports: ["create_cosine_ramp_weights", "extract_tiles", "reconstruct_from_tiles"]
  key_links:
    - from: "reconstruct_from_tiles"
      to: "create_cosine_ramp_weights"
      via: "uses weights for blending"
      pattern: "blend_weights.*create_cosine_ramp"
---

<objective>
Implement the tiling infrastructure for processing large SAR images.

Purpose: Enable memory-efficient processing of images larger than patch size (10000x10000 pixels) by splitting into overlapping tiles, processing individually, and reconstructing with seamless blending.

Output: `src/inference/tiling.py` with tile extraction, cosine ramp blending weights, and weighted reconstruction.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/05-inference/05-RESEARCH.md

# Key patterns from research
# - Cosine-squared ramp: `np.sin(np.linspace(0, np.pi/2, overlap)) ** 2`
# - Reflection padding for edges
# - Weight normalization: `output / weight_sum`
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create tiling module with extraction and blending</name>
  <files>src/inference/tiling.py</files>
  <action>
Create `src/inference/tiling.py` with the following functions:

1. **create_cosine_ramp_weights(tile_size: int, overlap: int) -> np.ndarray**
   - Create 2D blending weights (tile_size x tile_size)
   - Center of tile = 1.0
   - Overlap regions use cosine-squared ramp from 0 to 1
   - Apply ramps to all four edges
   - Handle corner regions (multiply horizontal and vertical ramps)
   - Return float32 array

2. **extract_tiles(image: np.ndarray, tile_size: int = 256, overlap: int = 64) -> Tuple[np.ndarray, Dict]**
   - Accept 2D numpy array (H, W)
   - Compute stride = tile_size - overlap
   - Compute padding needed to make image divisible by stride
   - Pad with reflection mode (mode='reflect')
   - Extract tiles in row-major order
   - Return:
     - tiles: (N, tile_size, tile_size) array
     - metadata: Dict with grid_shape, original_shape, padded_shape, padding, tile_size, overlap, stride

3. **reconstruct_from_tiles(tiles: np.ndarray, metadata: Dict, blend_weights: np.ndarray) -> np.ndarray**
   - Initialize output and weight_sum accumulators (zeros, float32)
   - For each tile, add tile * blend_weights to output
   - Add blend_weights to weight_sum
   - Normalize: output = output / weight_sum (with where=weight_sum > 0)
   - Crop to original_shape
   - Return reconstructed image

Add type hints, docstrings, and handle edge cases:
- Images smaller than tile_size: pad to tile_size
- Zero overlap: use uniform weights (all 1.0)
- Empty image: raise ValueError

Include test function `test_tiling()` that:
- Creates 512x512 test image
- Extracts tiles with overlap=64
- Reconstructs with identity transform (tiles unchanged)
- Verifies reconstruction matches original within floating point tolerance
- Tests cosine weights sum correctly in overlap regions
  </action>
  <verify>
Run: `python -c "from src.inference.tiling import test_tiling; test_tiling()"`
Expected: All tests pass with printed confirmation
  </verify>
  <done>
- extract_tiles produces correct number of tiles for various image sizes
- create_cosine_ramp_weights produces weights that sum to 1.0 when overlapped
- reconstruct_from_tiles with unchanged tiles returns original image (within tolerance)
- Module importable with no errors
  </done>
</task>

<task type="auto">
  <name>Task 2: Add visualization helper for blend weights</name>
  <files>src/inference/tiling.py</files>
  <action>
Add a visualization function to `src/inference/tiling.py`:

**visualize_blend_weights(tile_size: int, overlap: int, output_path: Optional[str] = None) -> None**
- Create cosine ramp weights
- Create matplotlib figure showing:
  - 2D heatmap of weights
  - 1D cross-section through center (horizontal)
  - Title with tile_size and overlap
- If output_path provided, save figure
- Otherwise, show figure

This is useful for debugging blending and verifying smooth transitions. Use this at end of test_tiling() to save a sample visualization to `notebooks/evaluations/blend_weights_sample.png`.

Also add to test_tiling():
- Test that weights at tile corners (overlap region) are < 0.5
- Test that weights at tile center are 1.0
- Test reconstruction error is < 1e-5 for identity transform
  </action>
  <verify>
Run: `python -c "from src.inference.tiling import test_tiling; test_tiling()"`
Expected: Tests pass, blend_weights_sample.png created in notebooks/evaluations/
  </verify>
  <done>
- visualize_blend_weights saves interpretable heatmap
- test_tiling includes weight property assertions
- Sample visualization exists at notebooks/evaluations/blend_weights_sample.png
  </done>
</task>

</tasks>

<verification>
1. `python -c "from src.inference.tiling import create_cosine_ramp_weights, extract_tiles, reconstruct_from_tiles"` - imports without error
2. `python -c "from src.inference.tiling import test_tiling; test_tiling()"` - all tests pass
3. File exists: `notebooks/evaluations/blend_weights_sample.png`
</verification>

<success_criteria>
- Tiling module implements all three core functions
- Cosine ramp weights produce smooth blending (verified by test)
- Round-trip extraction + reconstruction preserves image data
- Visualization helper works for debugging
</success_criteria>

<output>
After completion, create `.planning/phases/05-inference/05-01-SUMMARY.md`
</output>
