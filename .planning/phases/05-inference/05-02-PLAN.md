---
phase: 05-inference
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - src/inference/geotiff.py
autonomous: true

must_haves:
  truths:
    - "GeoTIFF loaded with full metadata (CRS, transform, nodata)"
    - "Output GeoTIFF preserves geospatial metadata from input"
    - "Nodata pixels pass through unchanged"
    - "Multi-band images handled correctly"
  artifacts:
    - path: "src/inference/geotiff.py"
      provides: "GeoTIFF I/O with metadata preservation"
      exports: ["read_geotiff", "write_geotiff", "GeoMetadata"]
  key_links:
    - from: "write_geotiff"
      to: "GeoMetadata"
      via: "uses metadata for output profile"
      pattern: "metadata.*crs.*transform"
---

<objective>
Implement GeoTIFF I/O with full metadata preservation for the compression pipeline.

Purpose: Enable end-to-end compression of raw Sentinel-1 GeoTIFF files while preserving georeferencing (CRS, transform) and handling nodata pixels correctly.

Output: `src/inference/geotiff.py` with read/write functions and metadata dataclass.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/05-inference/05-RESEARCH.md

# Key patterns from research
# - rasterio for GeoTIFF I/O (already in requirements.txt)
# - Preserve CRS, transform, nodata, tags
# - Optional COG output via rio-cogeo
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create GeoTIFF I/O module</name>
  <files>src/inference/geotiff.py</files>
  <action>
Create `src/inference/geotiff.py` with the following:

1. **GeoMetadata dataclass**
```python
@dataclass
class GeoMetadata:
    crs: Optional[Any]  # rasterio CRS or None
    transform: Optional[Any]  # rasterio Affine or None
    nodata: Optional[float]
    dtype: str
    count: int  # number of bands
    width: int
    height: int
    tags: Dict[str, str]
    descriptions: Optional[Tuple[str, ...]]
```

2. **read_geotiff(path: Union[str, Path]) -> Tuple[np.ndarray, GeoMetadata]**
   - Open file with rasterio
   - Read all bands: data shape (count, H, W) or (H, W) for single band
   - Extract GeoMetadata from source profile
   - Handle missing CRS gracefully (set to None, warn user)
   - Return data and metadata

3. **write_geotiff(data: np.ndarray, metadata: GeoMetadata, path: Union[str, Path], compress: str = 'lzw') -> None**
   - Build rasterio profile from metadata
   - Handle 2D (single band) and 3D (multi-band) data
   - Apply compression (LZW default)
   - Write tags if present
   - Warn if CRS is None (output won't be georeferenced)

4. **create_nodata_mask(data: np.ndarray, nodata: Optional[float]) -> np.ndarray**
   - Return boolean mask where True = nodata pixel
   - Handle None nodata (return all False)
   - Handle NaN nodata values

5. **apply_nodata_mask(data: np.ndarray, mask: np.ndarray, nodata_value: float) -> np.ndarray**
   - Set masked pixels to nodata_value
   - Return modified copy

Add imports: rasterio, numpy, dataclasses, typing, warnings, pathlib

Include test function `test_geotiff_io()` that:
- Creates synthetic 256x256 float32 data
- Creates GeoMetadata with mock CRS (can use rasterio.crs.CRS.from_epsg(4326))
- Writes to temp file
- Reads back
- Verifies data matches, metadata preserved
- Cleans up temp file
  </action>
  <verify>
Run: `python -c "from src.inference.geotiff import test_geotiff_io; test_geotiff_io()"`
Expected: Test passes with printed confirmation
  </verify>
  <done>
- GeoMetadata dataclass captures all relevant fields
- read_geotiff extracts full metadata from file
- write_geotiff produces valid GeoTIFF with preserved metadata
- Round-trip read/write preserves data and metadata
  </done>
</task>

<task type="auto">
  <name>Task 2: Add optional COG output support</name>
  <files>src/inference/geotiff.py, requirements.txt</files>
  <action>
Extend `src/inference/geotiff.py` with Cloud Optimized GeoTIFF support:

1. **write_cog(data: np.ndarray, metadata: GeoMetadata, path: Union[str, Path]) -> None**
   - Check if rio_cogeo is available (try import, catch ImportError)
   - If not available, fall back to regular write_geotiff with warning
   - If available:
     - Write temp GeoTIFF in memory (MemoryFile)
     - Use cog_translate to create COG
     - Default profile: "deflate"

2. Add to requirements.txt (if not present):
   - rich>=14.1.0 (for progress bars in later plans)
   - rio-cogeo>=5.4.0 (optional, for COG support)

3. Update test_geotiff_io() to also test:
   - write_cog creates valid file (if rio_cogeo installed)
   - Falls back gracefully if rio_cogeo not installed

Note: rio-cogeo is optional. The CLI will use regular GeoTIFF by default, COG only when --cog flag specified.
  </action>
  <verify>
Run: `python -c "from src.inference.geotiff import write_cog; print('COG support available')"`
Expected: Either "COG support available" or fallback warning (both acceptable)
  </verify>
  <done>
- write_cog function exists and handles missing rio-cogeo gracefully
- requirements.txt updated with rich (required) and rio-cogeo (optional)
- Test confirms round-trip works with or without COG
  </done>
</task>

</tasks>

<verification>
1. `python -c "from src.inference.geotiff import read_geotiff, write_geotiff, GeoMetadata"` - imports without error
2. `python -c "from src.inference.geotiff import test_geotiff_io; test_geotiff_io()"` - all tests pass
3. `grep -q "rich" requirements.txt && echo "rich in requirements"` - rich added
</verification>

<success_criteria>
- GeoTIFF I/O module handles read/write with metadata preservation
- Nodata masking works correctly
- Optional COG support with graceful fallback
- Tests verify round-trip integrity
</success_criteria>

<output>
After completion, create `.planning/phases/05-inference/05-02-SUMMARY.md`
</output>
