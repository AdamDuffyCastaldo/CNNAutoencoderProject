---
phase: 03-sar-evaluation
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - src/evaluation/codec_baselines.py
  - src/evaluation/__init__.py
autonomous: true

# NOTE: WebP codec excluded by design. FR4.11 states "optionally JPEG, WebP" for baselines.
# JPEG-2000 + JPEG provide sufficient traditional codec comparison:
# - JPEG-2000: High-quality wavelet-based (best traditional for continuous-tone images)
# - JPEG: Common lossy baseline (DCT-based, widespread deployment)
# WebP would add complexity without meaningful differentiation for SAR evaluation.

must_haves:
  truths:
    - "JPEG-2000 encodes and decodes SAR patches correctly"
    - "JPEG encodes and decodes SAR patches correctly"
    - "Codec compression produces file sizes within 20% of target compression ratio"
    - "Codec evaluation uses same metrics as autoencoder evaluation"
  artifacts:
    - path: "src/evaluation/codec_baselines.py"
      provides: "Traditional codec compression and evaluation"
      exports: ["Codec", "JPEG2000Codec", "JPEGCodec", "CodecEvaluator"]
      min_lines: 200
    - path: "src/evaluation/__init__.py"
      provides: "Updated exports"
      contains: "CodecEvaluator"
  key_links:
    - from: "src/evaluation/codec_baselines.py"
      to: "cv2"
      via: "imencode, imdecode"
      pattern: "cv2\\.(imencode|imdecode)"
    - from: "src/evaluation/codec_baselines.py"
      to: "src/evaluation/metrics.py"
      via: "compute_all_metrics import"
      pattern: "from .metrics import"
---

<objective>
Implement traditional codec baselines (JPEG-2000, JPEG) for comparison with autoencoder compression. Include compression parameter calibration to match target compression ratios.

Purpose: Establish meaningful baselines by comparing autoencoder quality against traditional codecs at equivalent compression ratios (8x, 16x, 32x). This enables objective assessment of whether the autoencoder provides value over established compression methods.

Output: New `src/evaluation/codec_baselines.py` with codec implementations and evaluation utilities.

Note: WebP codec is intentionally excluded. FR4.11 lists JPEG and WebP as optional baselines. JPEG-2000 (wavelet-based, high quality) and JPEG (DCT-based, ubiquitous) provide sufficient coverage for meaningful comparison without adding unnecessary complexity.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-sar-evaluation/03-RESEARCH.md
@.planning/phases/03-sar-evaluation/03-CONTEXT.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create base Codec class and JPEG-2000 implementation</name>
  <files>src/evaluation/codec_baselines.py</files>
  <action>
Create new file `src/evaluation/codec_baselines.py` with codec infrastructure.

1. Create abstract base class `Codec`:
   ```python
   class Codec:
       name: str  # e.g., "jpeg2000", "jpeg"

       def encode(self, image: np.ndarray, quality: int) -> bytes:
           """Encode image to bytes. Quality parameter is codec-specific."""
           raise NotImplementedError

       def decode(self, encoded: bytes) -> np.ndarray:
           """Decode bytes back to image."""
           raise NotImplementedError

       def get_compression_ratio(self, image: np.ndarray, encoded: bytes) -> float:
           """Calculate achieved compression ratio."""
           original_bytes = image.size * 4  # float32
           return original_bytes / len(encoded)

       def calibrate_quality(self, target_ratio: float, sample_image: np.ndarray, tolerance: float = 0.2) -> int:
           """Binary search to find quality parameter achieving target compression ratio."""
           # Implement binary search
   ```

2. Implement `JPEG2000Codec(Codec)`:
   - Use OpenCV cv2.imencode('.jp2', ...) and cv2.imdecode(...)
   - Quality parameter: IMWRITE_JPEG2000_COMPRESSION_X1000 (range 1-1000, lower = more compression)
   - Convert input [0,1] float to uint8 for encoding, back to float32 for decoding:
     ```python
     def encode(self, image: np.ndarray, quality: int) -> bytes:
         img_uint8 = (image * 255).astype(np.uint8)
         encode_params = [cv2.IMWRITE_JPEG2000_COMPRESSION_X1000, quality]
         success, encoded = cv2.imencode('.jp2', img_uint8, encode_params)
         if not success:
             raise RuntimeError("JPEG-2000 encoding failed")
         return encoded.tobytes()

     def decode(self, encoded: bytes) -> np.ndarray:
         arr = np.frombuffer(encoded, dtype=np.uint8)
         decoded = cv2.imdecode(arr, cv2.IMREAD_UNCHANGED)
         return decoded.astype(np.float32) / 255.0
     ```

3. Add compression ratio calibration via binary search:
   ```python
   def calibrate_quality(self, target_ratio: float, sample_image: np.ndarray,
                         tolerance: float = 0.2) -> int:
       original_bytes = sample_image.size * 4
       low, high = 1, 1000
       best_param, best_diff = 500, float('inf')

       while low <= high:
           mid = (low + high) // 2
           encoded = self.encode(sample_image, mid)
           achieved_ratio = original_bytes / len(encoded)

           diff = abs(achieved_ratio - target_ratio) / target_ratio
           if diff < best_diff:
               best_diff, best_param = diff, mid

           if achieved_ratio > target_ratio:
               high = mid - 1  # Need more compression
           else:
               low = mid + 1   # Need less compression

           if diff < tolerance:
               break

       return best_param
   ```

4. Handle edge cases:
   - Check if OpenCV was built with JPEG-2000 support (may need jasper/openjpeg)
   - Graceful fallback with clear error message if not available
  </action>
  <verify>
Test JPEG-2000 encoding/decoding:
```python
import numpy as np
import cv2

# Check JPEG-2000 support
test_img = np.random.rand(64, 64).astype(np.float32)
img_uint8 = (test_img * 255).astype(np.uint8)
success, encoded = cv2.imencode('.jp2', img_uint8, [cv2.IMWRITE_JPEG2000_COMPRESSION_X1000, 100])
if not success:
    print("WARNING: JPEG-2000 not supported in this OpenCV build")
else:
    from src.evaluation.codec_baselines import JPEG2000Codec
    codec = JPEG2000Codec()
    encoded = codec.encode(test_img, quality=100)
    decoded = codec.decode(encoded)
    print(f"Original shape: {test_img.shape}, Decoded shape: {decoded.shape}")
    print(f"Compression ratio: {codec.get_compression_ratio(test_img, encoded):.2f}x")
```
  </verify>
  <done>
JPEG2000Codec class encodes/decodes correctly. Compression ratio calculation works. Binary search calibration finds quality parameter within tolerance.
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement JPEG codec and CodecEvaluator</name>
  <files>src/evaluation/codec_baselines.py</files>
  <action>
Add JPEG codec and evaluation infrastructure.

1. Implement `JPEGCodec(Codec)`:
   - Use cv2.imencode('.jpg', ...) with IMWRITE_JPEG_QUALITY parameter
   - Quality range: 0-100 (higher = less compression)
   - Same float32 -> uint8 -> float32 conversion pattern
   - JPEG is lossy and doesn't preserve edges as well, good baseline

2. Create `CodecEvaluator` class:
   ```python
   class CodecEvaluator:
       def __init__(self, codec: Codec, cache_dir: Optional[str] = None):
           self.codec = codec
           self.cache_dir = Path(cache_dir) if cache_dir else None
           self.calibrated_params = {}  # target_ratio -> quality_param

       def calibrate(self, target_ratios: List[float], sample_images: List[np.ndarray]):
           """Calibrate quality parameters for target compression ratios."""
           # Average calibration across multiple sample images for robustness

       def evaluate_single(self, image: np.ndarray, target_ratio: float) -> dict:
           """Encode, decode, compute metrics for single image."""
           # Use calibrated quality parameter
           # Compute: psnr, ssim, ms_ssim, epi, histogram similarity
           # Return dict with metrics + achieved_ratio

       def evaluate_batch(self, images: List[np.ndarray], target_ratio: float,
                          show_progress: bool = True) -> dict:
           """Evaluate across batch, return statistics."""
           # Compute mean/std of all metrics

       def save_results(self, results: dict, output_path: str):
           """Save evaluation results to JSON."""
   ```

3. Add caching for encoded files (per CONTEXT.md decision):
   - Cache key: hash of image + codec + quality
   - Store in cache_dir if provided
   - Skip encoding if cached version exists

4. Import compute_all_metrics (or individual metrics) from .metrics for consistency
  </action>
  <verify>
Test codec evaluator:
```python
import numpy as np
from src.evaluation.codec_baselines import JPEGCodec, CodecEvaluator

# Create test images
images = [np.random.rand(256, 256).astype(np.float32) for _ in range(5)]

# Test JPEG codec
codec = JPEGCodec()
evaluator = CodecEvaluator(codec)

# Calibrate for 16x compression
evaluator.calibrate([16.0], images[:2])
print(f"Calibrated quality for 16x: {evaluator.calibrated_params.get(16.0)}")

# Evaluate single image
result = evaluator.evaluate_single(images[0], target_ratio=16.0)
print(f"PSNR: {result['psnr']:.2f}, Achieved ratio: {result['achieved_ratio']:.2f}x")
```
  </verify>
  <done>
JPEGCodec encodes/decodes correctly. CodecEvaluator calibrates quality parameters and evaluates images with same metrics as autoencoder evaluation.
  </done>
</task>

<task type="auto">
  <name>Task 3: Add batch evaluation and update module exports</name>
  <files>src/evaluation/codec_baselines.py, src/evaluation/__init__.py</files>
  <action>
Complete codec evaluation infrastructure and integrate with module.

1. Complete `evaluate_batch` in CodecEvaluator:
   - Iterate with tqdm progress bar
   - Collect per-image metrics
   - Compute statistics (mean, std, min, max) for each metric
   - Return comprehensive results dict

2. Add `evaluate_at_ratios(images, target_ratios)` method:
   - Evaluate at multiple compression ratios (8x, 16x, 32x)
   - Return list of results, one per ratio
   - Useful for rate-distortion curves

3. Add results serialization:
   ```python
   def to_json(self, results: dict, path: str):
       """Save results to JSON with metadata."""
       output = {
           'codec': self.codec.name,
           'evaluation_date': datetime.now().isoformat(),
           'compression_ratio': results.get('target_ratio'),
           'achieved_ratio': results.get('achieved_ratio'),
           'metrics': results.get('metrics'),
       }
       with open(path, 'w') as f:
           json.dump(output, f, indent=2)
   ```

4. Update `src/evaluation/__init__.py`:
   - Add imports: `from .codec_baselines import Codec, JPEG2000Codec, JPEGCodec, CodecEvaluator`
   - Update __all__ list

5. Add module-level test function:
   ```python
   def test_codecs():
       """Test codec implementations."""
       # Test both JPEG and JPEG-2000 encode/decode
       # Test calibration
       # Test evaluation
   ```
  </action>
  <verify>
Run comprehensive codec test:
```bash
cd D:\Projects\CNNAutoencoderProject
python -c "
from src.evaluation.codec_baselines import JPEG2000Codec, JPEGCodec, CodecEvaluator
import numpy as np

# Test both codecs
images = [np.random.rand(256, 256).astype(np.float32) for _ in range(3)]

for CodecClass, name in [(JPEG2000Codec, 'JPEG-2000'), (JPEGCodec, 'JPEG')]:
    try:
        codec = CodecClass()
        evaluator = CodecEvaluator(codec)
        evaluator.calibrate([16.0], images[:1])
        result = evaluator.evaluate_single(images[0], 16.0)
        print(f'{name}: PSNR={result[\"psnr\"]:.2f}, achieved_ratio={result[\"achieved_ratio\"]:.2f}x')
    except Exception as e:
        print(f'{name}: {e}')

print('Codec tests complete')
"
```

Test imports:
```bash
cd D:\Projects\CNNAutoencoderProject
python -c "from src.evaluation import CodecEvaluator, JPEG2000Codec, JPEGCodec; print('Import successful')"
```
  </verify>
  <done>
evaluate_batch returns statistics dict. evaluate_at_ratios works for multiple ratios. Results can be saved to JSON. Module exports updated. Imports work correctly.
  </done>
</task>

</tasks>

<verification>
After all tasks complete:
1. `python -c "from src.evaluation import JPEG2000Codec, JPEGCodec, CodecEvaluator"` succeeds
2. JPEG-2000 achieves ~16x compression with calibration (within 20% tolerance)
3. JPEG achieves ~16x compression with calibration
4. CodecEvaluator.evaluate_single returns dict with psnr, ssim, achieved_ratio
5. Results can be serialized to JSON
</verification>

<success_criteria>
1. JPEG2000Codec and JPEGCodec encode/decode correctly (roundtrip test passes)
2. Calibration finds quality parameters within 20% of target compression ratio
3. CodecEvaluator uses same metrics as autoencoder evaluation (PSNR, SSIM, EPI)
4. Batch evaluation returns mean/std statistics
5. Results serializable to JSON
6. Module exports updated and imports work
</success_criteria>

<output>
After completion, create `.planning/phases/03-sar-evaluation/03-02-SUMMARY.md`
</output>
